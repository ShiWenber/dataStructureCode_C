package ynu.ls.coloring;

import ynu.ls.coloring.Graph;

import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.SimpleFileVisitor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.Vector;

import javax.lang.model.util.ElementScanner6;
import javax.management.relation.RelationSupportMBean;
import javax.print.event.PrintEvent;

public class TabuColoring {
	private Graph G;
	// 颜色数
	private int nbColor;
	// 二维表作为禁忌表，第0列表顶点，第1列-第k列表示颜色，值为禁忌次数
	private int[][] tabuTable;
	private int[][] moveScore;
	private int[][] moveScore2;
	private int[] best_sol;

	public TabuColoring(Graph G, int nbColor) {
		this.G = G;
		this.nbColor = nbColor;
		this.tabuTable = new int[G.verNum + 1][nbColor + 1];
		this.moveScore = new int[G.verNum + 1][nbColor + 1]; // moveScore[i][j] 表示顶点i的颜色变为j时的分数，分数越大越好
		this.moveScore2 = new int[G.verNum + 1][nbColor + 1]; // moveScore2[i][j] 表示顶点i的颜色变为j时的分数，分数越大越好
		this.best_sol = new int[G.verNum + 1];
	}

	/**
	 * 执行禁忌搜索，返回解 sol[i] 表示第 i 个顶点的颜色
	 * 
	 * @return
	 */
	public int[] search() {
		// 初始化随机解
		for (int i = 1; i < G.verNum + 1; i++) {
			// 产生从1~nbColor的随机数
			best_sol[i] = (int) (Math.random() * nbColor) + 1;
		}

		// 初始化最优解，这样记录最优解的时候方便跟禁忌中找到的局部最优解比较，todo:但是比较耗时
		// int sol_best[] = sol.clone(); // 是深拷贝？ TODO
		// int sol_best[] = Arrays.copyOf(sol, sol.length);

		// 初始化禁忌表和移动评分表
		for (int i = 1; i < G.verNum + 1; i++) {
			for (int j = 1; j < nbColor + 1; j++) {
				tabuTable[i][j] = 0;
				moveScore[i][j] = 0;
			}
		}

		// 初始化移动评分表
		calMoveScore(best_sol, moveScore);
		calMoveScore(best_sol, moveScore2);

		// 解评分，仅计算初始化的一次，后面只做增量式更新
		int conflict = calConflict(best_sol);

		int iter = 1; // 迭代次数
		int max_iter = 10000; // 最大迭代次数
		int randIdx = 5000; // 禁忌表中随机选择的禁忌次数
		// 注意一个iter才更新一次sol，且只有比sol_best好的才更新sol_best
		int x = 10;
		while (conflict > 0 && iter < max_iter) {
			System.out.println("conflict: " + conflict);
			// // 输出轮数
			System.out.print("---------iter: ");
			System.out.println(iter);
			// choose a best move (v, c_i, c_j) from non-tabu moves
			// 有非禁忌移动就从非禁忌移动中选择一个最好的，否则从禁忌移动中选择第一个move-score为正的
			int flag = 0; // 一次iter 中是否存在非禁忌的移动
			// 记录在禁忌期的最优移动
			// int maxMoveScore = moveScore[1][1]; // 一次iter 中最大的move-score
			// 初始化为最小值
			int maxMoveScore = Integer.MIN_VALUE;
			int bestMove_v = 1;
			int bestMoveColor_j = 1;
			flag = 0;
			// if (tabuTable[1][1] >= iter) {
			// flag = 1;
			// }
			// 记录非禁忌的最优移动
			int maxMoveScore_nonTabu = Integer.MIN_VALUE;
			int bestMove_v_nonTabu = 1;
			int bestMoveColor_j_nonTabu = 1;
			// int step = 2;
			int step = 1;
			// start 是 1, 2 中的随机数
			// int start = randInt(2) + 1;
			int start = 1;

			// int max_score = ; // 一次iter 中最大的move-score
			for (int i = start; i < G.verNum + 1; i+=step) {
				for (int j = start; j < nbColor + 1; j+=step) {
					// 记录所有的分数，找出最大的分数
					if (moveScore[i][j] > maxMoveScore) {
						maxMoveScore = moveScore[i][j];
						bestMove_v = i;
						bestMoveColor_j = j;
						flag = 1;
					} else if (moveScore[i][j] == maxMoveScore && randInt(10) > 5) {
						// 遇到相同的分数，随机选择一个
						maxMoveScore = moveScore[i][j];
						bestMove_v = i;
						bestMoveColor_j = j;
						flag = 1;
					}
					if (moveScore[i][j] > maxMoveScore_nonTabu && tabuTable[i][j] < iter) {
						maxMoveScore_nonTabu = moveScore[i][j];
						bestMove_v_nonTabu = i;
						bestMoveColor_j_nonTabu = j;
						flag = 1;
					} else if (moveScore[i][j] == maxMoveScore_nonTabu && tabuTable[i][j] < iter && randInt(10) > 5) {
						// 遇到相同的分数，随机选择一个
						maxMoveScore_nonTabu = moveScore[i][j];
						bestMove_v_nonTabu = i;
						bestMoveColor_j_nonTabu = j;
						flag = 1;
					}
				}
			}
			// 非禁忌的移动中，找到一个最优的移动
			if (flag == 1) {
				// 最佳解不禁忌
				if (tabuTable[bestMove_v][bestMoveColor_j] < iter) {
					int conflictDelta = -moveScore[bestMove_v][bestMoveColor_j];
					System.out.println("bestMove: " + bestMove_v + " " + bestMoveColor_j + " " + conflictDelta);
					move(best_sol, bestMove_v, best_sol[bestMove_v], bestMoveColor_j);
					assert (best_sol[bestMove_v] == bestMoveColor_j);
					// System.out.print("conlict: ");
					// System.out.println(calConflict(sol));
					tabuTable[bestMove_v][bestMoveColor_j] = iter + randIdx * iter/max_iter;
					assert (calConflict(best_sol) == conflict + conflictDelta);
					conflict += conflictDelta;
					// printTabu(tabuTable);
					// printMoveScore(moveScore);
					iter++;
				} else if (moveScore[bestMove_v][bestMoveColor_j] > 0) {
					// 最佳解禁忌但是move-score为正
					int conflictDelta = -moveScore[bestMove_v][bestMoveColor_j];
					System.out.println("bestMove_moveScore>0: " + bestMove_v + " " + bestMoveColor_j + " " + conflictDelta);
					move(best_sol, bestMove_v, best_sol[bestMove_v], bestMoveColor_j);
					assert (best_sol[bestMove_v] == bestMoveColor_j);
					// System.out.print("conlict: ");
					// System.out.println(calConflict(sol));
					tabuTable[bestMove_v][bestMoveColor_j] = iter +  randIdx * iter / max_iter;
					assert (calConflict(best_sol) == conflict + conflictDelta);
					conflict += conflictDelta;
					// printTabu(tabuTable);
					// printMoveScore(moveScore);
					iter++;
				} else {
					// 最佳解禁忌且move-score为负，则从非禁忌的移动中选择一个最优的移动
					int conflictDelta = -maxMoveScore_nonTabu;
					System.out.println("bestMove_nonTabu: " + bestMove_v_nonTabu + " " + bestMoveColor_j_nonTabu + " "
							+ conflictDelta);
					move(best_sol, bestMove_v_nonTabu, best_sol[bestMove_v_nonTabu], bestMoveColor_j_nonTabu);
					assert (best_sol[bestMove_v_nonTabu] == bestMoveColor_j_nonTabu);
					tabuTable[bestMove_v_nonTabu][bestMoveColor_j_nonTabu] = iter +  randIdx * iter / max_iter;
					assert (calConflict(best_sol) == conflict + conflictDelta);
					conflict += conflictDelta;
					iter++;
				}
			} else {
				// 存在一种情况flag为0，maxMoveScore为moveScore[1][1]，但是这个移动是非禁忌的，而且不存在禁忌且比moveScore[1][1]更好的移动
				// 那么不做任何动作，直接进入下一次迭代
				iter++;
			}
			// if (temp_iter == iter) {
			// printMoveScore(moveScore);
			// printMoveScore(tabuTable);
			// }
		}
		// if (conflict == 1) {
		// printMoveScore(moveScore);
		// printMoveScore(tabuTable);
		// // 通过输入暂时阻塞在此处
		// Scanner sc = new Scanner(System.in);
		// sc.nextLine();
		// System.out.println("conflict: " + conflict);
		// }
		// System.out.println(iter);
		// System.out.println(calConflict(sol_best));
		// assert (calConflict(best_sol) == 0);
		System.out.println("con" +
				calConflict(best_sol));
		System.out.println("iter-" + iter);
		return best_sol;
	}

	private void printTabu(int[][] tabuTable) {
		for (int i = 1; i < G.verNum + 1; i++) {
			for (int j = 1; j < nbColor + 1; j++) {
				System.out.print(tabuTable[i][j]);
				System.out.print(",");
			}
			System.out.println("");
		}
		System.out.println("---------------------");
	}

	private void printMoveScore(int[][] moveScore) {
		for (int i = 1; i < G.verNum + 1; i++) {
			for (int j = 1; j < nbColor + 1; j++) {
				System.out.print(moveScore[i][j]);
				System.out.print(",");
			}
			System.out.println();
		}
		System.out.println("---------------------");
	}

	/**
	 * 产生随机整数
	 * 
	 * @param i
	 * @return
	 */
	private int randInt(int i) {
		return (int) (Math.random() * i);
	}

	/**
	 * 计算冲突数
	 * 
	 * @param sol
	 * @return
	 */
	public int calConflict(int[] sol) {
		int res = 0;
		for (int i = 1; i < G.verNum + 1; i++) {
			ArrayList<Integer> neighbors = G.getNeighbors(i);
			// todo
			for (int v : neighbors) {
				if (sol[v] == sol[i]) {
					res++;
				}
			}
		}
		assert (res % 2 == 0);
		// 冲突边会重复计算，因此要除以2
		return res / 2;
	}

	/**
	 * 计算移动评分表
	 * 
	 * @param sol
	 */
	public void calMoveScore(int[] sol, int[][] moveScore2) {
		int conflict_neighbor_origin = 0;
		int conflict_neighbor_new = 0;
		for (int i = 1; i < G.verNum + 1; i++) {
			for (int color = 1; color < nbColor + 1; color++) {
				conflict_neighbor_new = 0;
				conflict_neighbor_origin = 0;
				// 计算原有冲突数
				ArrayList<Integer> neighbors = G.getNeighbors(i);
				for (int v : neighbors) {
					if (sol[v] == sol[i]) {
						conflict_neighbor_origin++;
					}
					if (sol[v] == color) {
						conflict_neighbor_new++;
					}
				}
				moveScore2[i][color] = conflict_neighbor_origin - conflict_neighbor_new;
			}
		}
	}

	/**
	 * 移动顶点并更新moveScore,sol表
	 * 
	 * @param best_sol 当前解
	 * @param v        改变的顶点
	 * @param c_i      顶点原来的颜色
	 * @param c_j      顶点改变后的颜色
	 * @return 返回冲突数的变化
	 */
	public void move(int[] best_sol, int v, int c_i, int c_j) {
		// 更新范围：v和v的邻居
		// 更新邻居的moveScore
		best_sol[v] = c_j;

		int conflict_neighbor_new = 0;
		int conflict_neighbor_origin = 0;

		ArrayList<Integer> neighbors = G.getNeighbors(v);
		for (int u : neighbors) {
			for (int c = 1; c < nbColor + 1; c++) {
				conflict_neighbor_new = 0;
				conflict_neighbor_origin = 0;
				if (c == best_sol[u]) {
					moveScore[u][c] = 0;
					continue;
				}
				for (int w : G.getNeighbors(u)) {
					// 现在对邻居的颜色冲突数
					if (best_sol[u] == best_sol[w]) {
						conflict_neighbor_origin++;
					}
					// 如果变化为c，对邻居的颜色冲突数
					if (c == best_sol[w]) {
						conflict_neighbor_new++;
					}
				}
				moveScore[u][c] = conflict_neighbor_origin - conflict_neighbor_new;
			}
		}
		// 更新v的moveScore
		for (int c = 1; c < nbColor + 1; c++) {
			conflict_neighbor_new = 0;
			conflict_neighbor_origin = 0;
			if (c == c_j) {
				moveScore[v][c] = 0;
				continue;
			}
			for (int u : neighbors) {
				// 现在对邻居的颜色冲突数
				if (c_j == best_sol[u]) {
					conflict_neighbor_origin++;
				}
				// 如果变化为c，对邻居的颜色冲突数
				if (c == best_sol[u]) {
					conflict_neighbor_new++;
				}
			}
			moveScore[v][c] = conflict_neighbor_origin - conflict_neighbor_new;
		}

		// calMoveScore(best_sol, moveScore2); // 暴力法保证准确率，但是不如上面的方法快 TODO 上面的方法错误

		// assert (equal_array(moveScore, moveScore2));
	}

	/**
	 * 对比两个二维数组，查看数据是否一致
	 * 
	 * @param moveScore
	 * @param moveScore2
	 * @return
	 */
	public boolean equal_array(int[][] moveScore, int[][] moveScore2) {
		for (int i = 1; i < G.verNum + 1; i++) {
			for (int j = 1; j < nbColor + 1; j++) {
				if (moveScore[i][j] != moveScore2[i][j]) {
					System.out.println("error");
					return false;
				}
			}
		}
		return true;
	}
}
